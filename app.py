import streamlit as st
import os
import zipfile
import tempfile
import pandas as pd
import glob
import re
import plotly.graph_objects as go
import plotly.colors

# Set Streamlit page layout configurations
st.set_page_config(layout="wide")

# Styling for reducing header height
reduce_header_height_style = """
    <style>
        div.block-container {padding-top:1rem;}
        div.block-container {padding-bottom:1rem;}
    </style>
"""
st.markdown(reduce_header_height_style, unsafe_allow_html=True)

# Styling for hiding decoration bar

hide_decoration_bar_style = """
    <style>
        header {visibility: hidden;}
        footer {visibility: hidden;}
    </style>
"""
st.markdown(hide_decoration_bar_style, unsafe_allow_html=True)

# Function to print files with PHP extension in a given folder
# Fungsi untuk Ngambil File yang berekstensi PHP
def print_files_with_php_extension(folder_path):
    php_files = glob.glob(os.path.join(folder_path, "**", "*.php"), recursive=True)
    return php_files

# Function to check if a file has SQL queries
# fungsi untuk mengecek file yang mempunyai Query SQL
def has_sql_queries(file_path):
    
    sql_keywords = [
        r"\bselect\b.*\bfrom\b" ,
        r"\bwhere\b",
        r"\bgroup by\b",
        r"\border by\b",
        r"\binsert into\b",
        r"\bupdate\b.*\bset\b",
        r"\bdelete from\b"
    ]

    with open(file_path, "r") as f:
        content = f.read().lower()
        for keyword in sql_keywords:
            if re.search(keyword, content):
                return True
    return False

# Function to find missing functions in the content
# fungsi untuk mencari fungsi yang hilang dikonten
def find_missing_functions(content, functions):
    missing_functions = [func for func in functions if func not in content]
    return missing_functions

# Title
# Judul
st.markdown("<h1><center>Sql Injection and XSS Code Scanner</center></h1>", unsafe_allow_html=True)

st.markdown("<h2>📥 Data Input</h2>", unsafe_allow_html=True)

# File upload
# Upload File
zip_file = st.file_uploader("Upload a zip file containing the folder")

if zip_file is not None:
    # Create a temporary directory and file for the uploaded zip
    # Buat temp direktori dan file buat upload zip
    
    temp_dir = tempfile.TemporaryDirectory()
    temp_file_path = os.path.join(temp_dir.name, zip_file.name)

    with open(temp_file_path, "wb") as f:
        f.write(zip_file.read())

    folder_name = os.path.splitext(temp_file_path)[0]
    with zipfile.ZipFile(temp_file_path, "r") as zip_ref:
        zip_ref.extractall(folder_name)

    # Count the total number of files
    # Hitung berapa jumlah Filesnya 
    file_count = sum([len(files) for _, _, files in os.walk(folder_name)])
    st.write(f"Total number of files: {file_count}")

    col1, col2, col3 = st.columns(3)

    # Display PHP files
    # Menampilkan File PHP
    with col1:
        st.markdown("<h4>PHP Files</h4>", unsafe_allow_html=True)

        php_files = print_files_with_php_extension(folder_name)
        php_list = []
        for file in php_files:
            php_list.append(os.path.basename(file))

        if len(php_list) > 0:
            php_df = pd.DataFrame({"File": php_list})
            php_df = php_df.sort_values("File", key=lambda x: x.str.lower()).reset_index(drop=True)
            php_df.index += 1
            st.dataframe(php_df, use_container_width=True)

            php_statement = f"Total number of PHP files: {len(php_df)}"
        else:
            php_statement = "No PHP files found"

    # Display PHP files with SQL queries
    # Nampilin Files PHP yang punya query SQL
    with col2:
        st.markdown("<h4>PHP Files with SQL Queries</h4>", unsafe_allow_html=True)

        sql_files = []
        for file in php_files:
            if has_sql_queries(file):
                sql_files.append(os.path.basename(file))

        if len(sql_files) > 0:
            sql_df = pd.DataFrame({"File": sql_files})
            sql_df = sql_df.sort_values("File", key=lambda x: x.str.lower()).reset_index(drop=True)
            sql_df.index += 1
            st.dataframe(sql_df, use_container_width=True)

            sql_statement = f"Total number of PHP files with SQL queries: {len(sql_df)}"
        else:
            sql_statement = "No PHP files with SQL queries found"

    # Display PHP files with unsafe SQL queries
    # Nampilin PHP Files dengan Query yang tidak aman
    with col3:
        st.markdown("<h4>PHP Files with Unsafe SQL Queries</h4>", unsafe_allow_html=True)

        words_to_check = ["stripslashes", "mysql_real_escape_string"]
        missing_files = []
        missing_words = []

        for file in php_files:
            if has_sql_queries(file):
                with open(file, "r") as f:
                    content = f.read()
                    words_not_found = [word for word in words_to_check if word not in content]
                    if words_not_found:
                        missing_files.append(os.path.basename(file))
                        missing_words.append(words_not_found)

        if len(missing_files) > 0:
            missing_df = pd.DataFrame({"File": missing_files, "Missing Query": missing_words})
            missing_df = missing_df.sort_values("File", key=lambda x: x.str.lower()).reset_index(drop=True)
            missing_df.index += 1
            st.dataframe(missing_df, use_container_width=True)

            unsafe_sql_statement = f"Total number of PHP files with unsafe SQL queries: {len(missing_df)}"
        else:
            unsafe_sql_statement = "No PHP files with unsafe SQL queries found"

    col1, col2, col3 = st.columns(3)

    # Display info statements
    # Display info dibawah tabel
    with col1:
        st.info(php_statement, icon="ℹ️")

    with col2:
        st.info(sql_statement, icon="ℹ️")

    with col3:
        st.info(unsafe_sql_statement, icon="ℹ️")
        
         # Add code references
    if len(missing_files) > 0:
        with st.expander("Look at the code references"):
            tab1, tab2 = st.tabs(["imposibblesqlinjection.php", "imposibblexssstored.php"])

            with tab1:
                code1 = """
<!-- Impossible SQL Injection Source -->
<?php

if( isset( $_GET[ 'Submit' ] ) ) {
    // Check Anti-CSRF token
    checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );

    // Get input
    $id = $_GET[ 'id' ];

    // Was a number entered?
    if(is_numeric( $id )) {
        $id = intval ($id);
        switch ($_DVWA['SQLI_DB']) {
            case MYSQL:
                // Check the database
                $data = $db->prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' );
                $data->bindParam( ':id', $id, PDO::PARAM_INT );
                $data->execute();
                $row = $data->fetch();

                // Make sure only 1 result is returned
                if( $data->rowCount() == 1 ) {
                    // Get values
                    $first = $row[ 'first_name' ];
                    $last  = $row[ 'last_name' ];

                    // Feedback for end user
                    echo "<pre>ID: {$id}<br />First name: {$first}<br />Surname: {$last}</pre>";
                }
                break;
            case SQLITE:
                global $sqlite_db_connection;

                $stmt = $sqlite_db_connection->prepare('SELECT first_name, last_name FROM users WHERE user_id = :id LIMIT 1;' );
                $stmt->bindValue(':id',$id,SQLITE3_INTEGER);
                $result = $stmt->execute();
                $result->finalize();
                if ($result !== false) {
                    // There is no way to get the number of rows returned
                    // This checks the number of columns (not rows) just
                    // as a precaution, but it won't stop someone dumping
                    // multiple rows and viewing them one at a time.

                    $num_columns = $result->numColumns();
                    if ($num_columns == 2) {
                        $row = $result->fetchArray();

                        // Get values
                        $first = $row[ 'first_name' ];
                        $last  = $row[ 'last_name' ];

                        // Feedback for end user
                        echo "<pre>ID: {$id}<br />First name: {$first}<br />Surname: {$last}</pre>";
                    }
                }

                break;
        }
    }
}

// Generate Anti-CSRF token
generateSessionToken();

?>
                """
                st.code(code1, language="php")

            with tab2:
                code2 = """
<!-- Impossible Stored XSS Source -->
<?php

if( isset( $_POST[ 'btnSign' ] ) ) {
    // Check Anti-CSRF token
    checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );

    // Get input
    $message = trim( $_POST[ 'mtxMessage' ] );
    $name    = trim( $_POST[ 'txtName' ] );

    // Sanitize message input
    $message = stripslashes( $message );
    $message = ((isset($GLOBALS["___mysqli_ston"]) && is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $message ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));
    $message = htmlspecialchars( $message );

    // Sanitize name input
    $name = stripslashes( $name );
    $name = ((isset($GLOBALS["___mysqli_ston"]) && is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $name ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));
    $name = htmlspecialchars( $name );

    // Update database
    $data = $db->prepare( 'INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );' );
    $data->bindParam( ':message', $message, PDO::PARAM_STR );
    $data->bindParam( ':name', $name, PDO::PARAM_STR );
    $data->execute();
}

// Generate Anti-CSRF token
generateSessionToken();

?>
                """
                st.code(code2, language="php")

    st.markdown("<h2>📊 Data Visualization</h2>", unsafe_allow_html=True)


  
    # Membuat PieChart

    labels = ["Other Files (not PHP)", "PHP Files without SQL Queries", "PHP Files with Safe SQL Queries", "PHP Files with Unsafe SQL Queries"]
    values = [file_count - len(php_df), len(php_df) - len(sql_df), len(sql_df) - len(missing_df), len(missing_df)]

    fig = go.Figure(data=go.Pie(
        labels=labels,
        values=values,
        hole=0.3,
        textinfo="percent",
        marker=dict(colors=plotly.colors.sequential.Teal)
    ))
    fig.update_layout(
        margin=dict(t=20),
        height=400
    )
    st.plotly_chart(fig)
    # st.plotly_chart(fig, use_container_width=True)
    
    
      # Download button for all dataframes
    # Download Hasil jadi EXcel files
    
    if (len(php_list) > 0) or (len(sql_files) > 0) or (len(missing_files) > 0):
        with tempfile.NamedTemporaryFile(suffix=".xlsx", delete=False) as temp_file:
            temp_file_path = temp_file.name
            writer = pd.ExcelWriter(temp_file_path, engine="xlsxwriter")

            if len(php_list) > 0:
                php_df.to_excel(writer, sheet_name="PHP Files", index=False)

            if len(sql_files) > 0:
                sql_df.to_excel(writer, sheet_name="SQL Queries", index=False)

            if len(missing_files) > 0:
                missing_df.to_excel(writer, sheet_name="Unsafe SQL Queries", index=False)

            writer.close()

            with open(temp_file_path, "rb") as f:
                bytes_data = f.read()
        
        st.download_button(
            label="Download Results as Excel",
            data=bytes_data,
            file_name="Results.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )

        os.remove(temp_file_path)

    # Cleanup temporary directory
    temp_dir.cleanup()